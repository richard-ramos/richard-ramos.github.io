{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/print","webpackCompilationHash":"0d19c64b9137d7a7d71a","result":{"data":{"deck":{"id":"0f087d16-3381-56d0-a611-782ddcef0920","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = vsDark;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ nimble init echo\\n$ cd echo\\n$ nimble install libp2p\\n$ vi src/echo.nim \\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import libp2p\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nproc main() {.async.} =\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n\\n  await switch1.start()\\n  await switch2.start()\\n\\n  # TODO:\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n\\n  await switch1.start()\\n  await switch2.start()\\n\\n  # TODO:\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\\nwaitFor(main())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nconst TestCodec = \\\"/test/proto/1.0.0\\\"\\n\\ntype TestProto = ref object of LPProtocol\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n\\n  await switch1.start()\\n  await switch2.start()\\n\\n  # TODO:\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\\nwaitFor(main())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nconst TestCodec = \\\"/test/proto/1.0.0\\\"\\n\\ntype TestProto = ref object of LPProtocol\\n\\nproc new(T: typedesc[TestProto]): T =\\n  proc handle(conn: Connection, proto: string) {.async: (raises: [CancelledError]).} =\\n    # TODO: implement protocol handler\\n    await conn.close()\\n\\n  return T.new(codecs = @[TestCodec], handler = handle)\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n\\n  await switch1.start()\\n  await switch2.start()\\n\\n  # TODO:\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\\nwaitFor(main())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nconst TestCodec = \\\"/test/proto/1.0.0\\\"\\n\\ntype TestProto = ref object of LPProtocol\\n\\nproc new(T: typedesc[TestProto]): T =\\n  proc handle(conn: Connection, proto: string) {.async: (raises: [CancelledError]).} =\\n    # TODO: implement protocol handler\\n    await conn.close()\\n\\n  return T.new(codecs = @[TestCodec], handler = handle)\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n    testProto = TestProto.new()\\n\\n  switch2.mount(testProto)\\n  \\n  await switch1.start()\\n  await switch2.start()\\n\\n  # TODO:\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\\nwaitFor(main())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nconst TestCodec = \\\"/test/proto/1.0.0\\\"\\n\\ntype TestProto = ref object of LPProtocol\\n\\nproc new(T: typedesc[TestProto]): T =\\n  proc handle(conn: Connection, proto: string) {.async: (raises: [CancelledError]).} =\\n    # TODO: implement protocol handler\\n    await conn.close()\\n\\n  return T.new(codecs = @[TestCodec], handler = handle)\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n    testProto = TestProto.new()\\n\\n  switch2.mount(testProto)\\n  \\n  await switch1.start()\\n  await switch2.start()\\n\\n  let conn =\\n    await switch1.dial(switch2.peerInfo.peerId, switch2.peerInfo.addrs, TestCodec)\\n\\n  # TODO: send request to protocol\\n\\n  await conn.close()\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\\nwaitFor(main())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nconst TestCodec = \\\"/test/proto/1.0.0\\\"\\n\\ntype TestProto = ref object of LPProtocol\\n\\nproc new(T: typedesc[TestProto]): T =\\n  proc handle(conn: Connection, proto: string) {.async: (raises: [CancelledError]).} =\\n    # TODO: implement protocol handler\\n    await conn.close()\\n\\n  return T.new(codecs = @[TestCodec], handler = handle)\\n\\nproc hello(p: TestProto, conn: Connection) {.async.} =\\n  await conn.writeLp(\\\"Hello\\\")\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n    testProto = TestProto.new()\\n\\n  switch2.mount(testProto)\\n  \\n  await switch1.start()\\n  await switch2.start()\\n\\n  let conn =\\n    await switch1.dial(switch2.peerInfo.peerId, switch2.peerInfo.addrs, TestCodec)\\n\\n  # TODO: send request to protocol\\n\\n  await conn.close()\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\\nwaitFor(main())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nconst TestCodec = \\\"/test/proto/1.0.0\\\"\\n\\ntype TestProto = ref object of LPProtocol\\n\\nproc new(T: typedesc[TestProto]): T =\\n  proc handle(conn: Connection, proto: string) {.async: (raises: [CancelledError]).} =\\n    try:\\n      let received = string.fromBytes(await conn.readLp(1024))\\n      echo \\\"Client says: \\\" & received\\n    except LPStreamError as e:\\n      echo \\\"exception: \\\" & e.msg\\n    finally:\\n      await conn.close()\\n\\n  return T.new(codecs = @[TestCodec], handler = handle)\\n\\nproc hello(p: TestProto, conn: Connection) {.async.} =\\n  await conn.writeLp(\\\"Hello\\\")\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n    testProto = TestProto.new()\\n\\n  switch2.mount(testProto)\\n  \\n  await switch1.start()\\n  await switch2.start()\\n\\n  let conn =\\n    await switch1.dial(switch2.peerInfo.peerId, switch2.peerInfo.addrs, TestCodec)\\n\\n  # TODO: send request to protocol\\n\\n  await conn.close()\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\\nwaitFor(main())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nconst TestCodec = \\\"/test/proto/1.0.0\\\"\\n\\ntype TestProto = ref object of LPProtocol\\n\\nproc new(T: typedesc[TestProto]): T =\\n  proc handle(conn: Connection, proto: string) {.async: (raises: [CancelledError]).} =\\n    try:\\n      let received = string.fromBytes(await conn.readLp(1024))\\n      echo \\\"Client says: \\\" & received\\n      await conn.writeLp(\\\"World\\\")\\n    except LPStreamError as e:\\n      echo \\\"exception: \\\" & e.msg\\n    finally:\\n      await conn.close()\\n\\n  return T.new(codecs = @[TestCodec], handler = handle)\\n\\nproc hello(p: TestProto, conn: Connection) {.async.} =\\n  await conn.writeLp(\\\"Hello\\\")\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n    testProto = TestProto.new()\\n\\n  switch2.mount(testProto)\\n  \\n  await switch1.start()\\n  await switch2.start()\\n\\n  let conn =\\n    await switch1.dial(switch2.peerInfo.peerId, switch2.peerInfo.addrs, TestCodec)\\n\\n  # TODO: send request to protocol\\n\\n  await conn.close()\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\\nwaitFor(main())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nconst TestCodec = \\\"/test/proto/1.0.0\\\"\\n\\ntype TestProto = ref object of LPProtocol\\n\\nproc new(T: typedesc[TestProto]): T =\\n  proc handle(conn: Connection, proto: string) {.async: (raises: [CancelledError]).} =\\n    try:\\n      let received = string.fromBytes(await conn.readLp(1024))\\n      echo \\\"Client says: \\\" & received\\n      await conn.writeLp(\\\"World\\\")\\n    except LPStreamError as e:\\n      echo \\\"exception: \\\" & e.msg\\n    finally:\\n      await conn.close()\\n\\n  return T.new(codecs = @[TestCodec], handler = handle)\\n\\nproc hello(p: TestProto, conn: Connection) {.async.} =\\n  await conn.writeLp(\\\"Hello\\\")\\n  let received = string.fromBytes(await conn.readLp(1024))\\n  echo \\\"Server says: \\\" & received\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n    testProto = TestProto.new()\\n\\n  switch2.mount(testProto)\\n  \\n  await switch1.start()\\n  await switch2.start()\\n\\n  let conn =\\n    await switch1.dial(switch2.peerInfo.peerId, switch2.peerInfo.addrs, TestCodec)\\n\\n  # TODO: send request to protocol\\n\\n  await conn.close()\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\\nwaitFor(main())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import chronos\\nimport libp2p\\n\\nproc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\\n  return SwitchBuilder\\n    .new()\\n    .withRng(rng)\\n    .withYamux()\\n    .withAddress(ma)\\n    .withNoise()\\n    .withTcpTransport()\\n    .build()\\n\\nconst TestCodec = \\\"/test/proto/1.0.0\\\"\\n\\ntype TestProto = ref object of LPProtocol\\n\\nproc new(T: typedesc[TestProto]): T =\\n  proc handle(conn: Connection, proto: string) {.async: (raises: [CancelledError]).} =\\n    try:\\n      let received = string.fromBytes(await conn.readLp(1024))\\n      echo \\\"Client says: \\\" & received\\n      await conn.writeLp(\\\"World\\\")\\n    except LPStreamError as e:\\n      echo \\\"exception: \\\" & e.msg\\n    finally:\\n      await conn.close()\\n\\n  return T.new(codecs = @[TestCodec], handler = handle)\\n\\nproc hello(p: TestProto, conn: Connection) {.async.} =\\n  await conn.writeLp(\\\"Hello\\\")\\n  let received = string.fromBytes(await conn.readLp(1024))\\n  echo \\\"Server says: \\\" & received\\n\\nproc main() {.async.} =\\n  let\\n    rng = newRng()\\n    localAddress = MultiAddress.init(\\\"/ip4/0.0.0.0/tcp/0\\\").tryGet()\\n    switch1 = createSwitch(localAddress, rng)\\n    switch2 = createSwitch(localAddress, rng)\\n    testProto = TestProto.new()\\n\\n  switch2.mount(testProto)\\n  \\n  await switch1.start()\\n  await switch2.start()\\n\\n  let conn =\\n    await switch1.dial(switch2.peerInfo.peerId, switch2.peerInfo.addrs, TestCodec)\\n\\n  await testProto.hello(conn)\\n\\n  await conn.close()\\n\\n  await switch1.stop()\\n  await switch2.stop()\\n\\nwaitFor(main())\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ nimble c --run echo.nim\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"0f087d16-3381-56d0-a611-782ddcef0920","slug":"","title":""}}}