{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/lmc/","result":{"data":{"site":{"siteMetadata":{"title":"Hello, I'm RichΛrd","social":[{"name":"twitter","url":"https://twitter.com/richardramos_me"},{"name":"github","url":"https://github.com/richard-ramos"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"bbc52208-7123-5822-b72b-143ef679c1f5","excerpt":"The Little Man Computer (LMC), created by Dr. Stuart Madnick in 1965, simulates a simple von Neumann architecture computer. It is used to…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Little Man Computer\",\n  \"date\": \"2020-04-10T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"hr\", null), mdx(\"p\", null, \"The Little Man Computer (LMC), created by Dr. Stuart Madnick in 1965, simulates a simple von Neumann architecture computer. It is used to explain how a computer works in easy-to-understand terms: Imagine a man in a room, whose job is to fetch instructions, decode and execute them continuously, acting as the control unit of a CPU. This room has an inbox, an outbox, 100 numbered mailboxes, a counter, and a accumulator or calculator that can only do addition and subtraction. The little man - using these tools - must follow these steps:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Read the number displayed in the Counter (it starts at 0)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Go to the mailbox with that same number, look and remember the number that appears on a slip of paper in that mailbox.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Push a button to increment the Counter\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Perform the instruction designated by the number on the slip of paper.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Go back to step 1 or halt\")), mdx(\"p\", null, \"There's a limited set of instructions that the little man can do:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"+---------+----------+------------------------------------------------------------------------+\\n| Numeric | Mnemonic | Description                                                            |\\n+---------+----------+------------------------------------------------------------------------+\\n| 000     | STOP     | Stops the Computer                                                     |\\n| 1xx     | ADD xx   | Adds the contents of the mailbox xx to the accumulator value           |\\n| 2xx     | SUB xx   | Subtracts the contents of the mailbox xx from the accumulator value    |\\n| 3xx     | STO xx   | Stores the accumulator value into the mailbox xx                       |\\n| 5xx     | LOAD xx  | Replace the accumulator value with the contents of the mailbox xx      |\\n| 6xx     | BRA xx   | Sets the counter to the number xx                                      |\\n| 7xx     | BRZ xx   | If the accumulator value is zero, sets the counter to the number xx    |\\n| 8xx     | BRP xx   | If the accumulator value is greater or equals to 0, then set the       |\\n|         |          | counter to the number xx                                               |\\n| 901     | READ     | Read a number from the inbox and write it into the accumulator         |\\n| 902     | PRINT    | Copy the number in the accumulator onto a slip of paper and place      |\\n|         |          | it into the outbox                                                     |\\n+---------+----------+------------------------------------------------------------------------+\\n\")), mdx(\"p\", null, \"We will write a small LMC. This write-up assumes you have Rust installed in your machine, if that is not the case, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.rust-lang.org/learn/get-started\"\n  }), \"install it!\"), \". \"), mdx(\"h2\", null, \"Project setup\"), mdx(\"p\", null, \"Let's start by creating a folder for our project and a new Rust package inside it. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"mkdir lmc\\ncd ./lmc\\ncargo init\\n\")), mdx(\"p\", null, \"This command will generate our project manifest \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cargo.toml\"), \" which contains all the metadata required to compile the project, and the default executable file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/main.rs\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"lmc\\n|-- .git\\n|-- .gitignore\\n|-- Cargo.toml\\n|-- src\\n    |-- main.rs\\n\")), mdx(\"p\", null, \"Executing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo run\"), \" will compile and execute the project:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"cargo run\\n  Compiling lmc v0.1.0 (/path/to/lmc)\\n  Finished dev [unoptimized + debuginfo] target(s) in 0.50s\\n    Running `target/debug/lmc`\\nHello world\\n\")), mdx(\"h2\", null, \"Reading arguments from the command line\"), mdx(\"p\", null, \"We need to fill the LMC mailboxes with up to 100 instructions. To indicate our program how whether we will read these instructions from the standard input or a file, we will use a command line flag.\"), mdx(\"p\", null, \"A nice way to do this is through the most popular crate to parse command line arguments: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://clap.rs\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"clap\")), \". We need to add this library to our dependencies in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cargo.toml\"), \" file.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-toml\"\n  }), \"[dependencies]\\nclap = \\\"2.33.0\\\"\\n\")), mdx(\"p\", null, \"And fetch this dependency and pre-compile it with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo build\"), \".\"), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// main.rs\\n\\nfn main() {\\n  println!(\\\"Hello, world!\\\");\\n}\\n\")), mdx(\"p\", null, \"Edit the main function of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main.rs\"), \" file. Currently it only prints \\\"Hello, world!\\\". Let's make it do something more interesting!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// main.rs\\n\\nuse clap::{Arg, App};\\n\\nfn main() {\\n  let matches = App::new(\\\"Little man computer\\\")\\n    .version(\\\"1.0\\\")\\n    .arg(Arg::with_name(\\\"file\\\")\\n      .short(\\\"f\\\")\\n      .long(\\\"file\\\")\\n      .help(\\\"Indicates that the input is a file path\\\")\\n      .takes_value(true))\\n      .get_matches();\\n}\\n\")), mdx(\"p\", null, \"Add the following code to make our program expect an optional flag \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--file\"), \". We can also use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-f\"), \". If you execute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo run -- --help\"), \", you'll see that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"clap\"), \" package displays some hints on what flags are expected.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// main.rs\\n\\nuse clap::{Arg, App};\\nuse std::io::{self, BufRead, BufReader};\\nuse std::fs::File;\\n\\nfn main() {\\n  let matches = App::new(\\\"Little man computer\\\")\\n    .version(\\\"1.0\\\")\\n    .arg(Arg::with_name(\\\"file\\\")\\n      .short(\\\"f\\\")\\n      .long(\\\"file\\\")\\n      .help(\\\"Indicates that the input is a file path\\\")\\n      .takes_value(true))\\n      .get_matches();\\n}\\n\")), mdx(\"p\", null, \"The next step is to read the instructions. Depending on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--file\"), \" flag we will read it from a file, or from the standard input. Start by importing som elements from the packages \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::io\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::fs\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// main.rs\\n\\nuse clap::{Arg, App};\\nuse std::io::{self, BufRead, BufReader};\\nuse std::fs::File;\\n\\nfn main() {\\n  let matches = App::new(\\\"Little man computer\\\")\\n    .version(\\\"1.0\\\")\\n    .arg(Arg::with_name(\\\"file\\\")\\n      .short(\\\"f\\\")\\n      .long(\\\"file\\\")\\n      .help(\\\"Indicates that the input is a file path\\\")\\n      .takes_value(true))\\n      .get_matches();\\n\\n  // If --file is present, read the values from a file\\n  let reader: Box<dyn BufRead> = match matches.value_of(\\\"file\\\") {\\n    Some(file_path) => {\\n      let path = std::path::PathBuf::from(file_path);\\n      let f = File::open(path).expect(\\\"File not found\\\");\\n      Box::new(BufReader::new(f))\\n    },\\n    None => Box::new(BufReader::new(io::stdin()))\\n  };\\n}\\n\")), mdx(\"p\", null, \"And create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reader\"), \" variable that will contain a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BufRead\"), \" trait object (both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"File\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"io::stdin()\"), \" implement this trait).\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// main.rs\\n\\nuse clap::{Arg, App};\\nuse std::io::{self, BufRead, BufReader};\\nuse std::fs::File;\\n\\nfn main() {\\n  let matches = App::new(\\\"Little man computer\\\")\\n    .version(\\\"1.0\\\")\\n    .arg(Arg::with_name(\\\"file\\\")\\n      .short(\\\"f\\\")\\n      .long(\\\"file\\\")\\n      .help(\\\"Indicates that the input is a file path\\\")\\n      .takes_value(true))\\n      .get_matches();\\n\\n  // If --file is present, read the values from a file\\n  let reader: Box<dyn BufRead> = match matches.value_of(\\\"file\\\") {\\n    Some(file_path) => {\\n      let path = std::path::PathBuf::from(file_path);\\n      let f = File::open(path).expect(\\\"File not found\\\");\\n      Box::new(BufReader::new(f))\\n    },\\n    None => Box::new(BufReader::new(io::stdin()))\\n  };\\n\\n  // Fill mailbox\\n  let mut mailbox: [i32; 100] = [0; 100];\\n  for (i, value) in reader.lines().enumerate() {\\n\\n  }\\n}\\n\")), mdx(\"p\", null, \"The LMC has a maximum number of 100 mailboxes, or memory slots available to hold our instructions. We will use an array of 100 elements initialized to 0 (the default state of our mailboxes). Then, using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reader\"), \" we will proceed to get all the values. The iterator \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"enumerate()\"), \" is useful because it returns a pair containing the current index of the iteration and the current value.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// main.rs\\n\\nuse clap::{Arg, App};\\nuse std::io::{self, BufRead, BufReader};\\nuse std::fs::File;\\n\\nfn main() {\\n  let matches = App::new(\\\"Little man computer\\\")\\n    .version(\\\"1.0\\\")\\n    .arg(Arg::with_name(\\\"file\\\")\\n      .short(\\\"f\\\")\\n      .long(\\\"file\\\")\\n      .help(\\\"Indicates that the input is a file path\\\")\\n      .takes_value(true))\\n      .get_matches();\\n\\n  // If --file is present, read the values from a file\\n  let reader: Box<dyn BufRead> = match matches.value_of(\\\"file\\\") {\\n    Some(file_path) => {\\n      let path = std::path::PathBuf::from(file_path);\\n      let f = File::open(path).expect(\\\"File not found\\\");\\n      Box::new(BufReader::new(f))\\n    },\\n    None => Box::new(BufReader::new(io::stdin()))\\n  };\\n\\n  // Fill mailbox\\n  let mut mailbox: [i32; 100] = [0; 100];\\n  for (i, value) in reader.lines().enumerate() {\\n    mailbox[i] = value.unwrap()\\n                      .trim()\\n                      .parse()\\n                      .expect(&format!(\\\"NaN on line {}\\\", i + 1));\\n\\n    if i == 99 {\\n      break;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Then, fill the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mailbox\"), \" array with the values from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reader\"), \". Notice the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".expect\"), \" here is used to make our program exit if we can't read the file. Since the LMC can only have 100 mailboxes, we break out of the loop once we reach index 99 (because arrays in Rust are zero-based).\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// main.rs\\n\\nuse clap::{Arg, App};\\nuse std::io::{self, BufRead, BufReader};\\nuse std::fs::File;\\n\\nfn main() {\\n  let matches = App::new(\\\"Little man computer\\\")\\n    .version(\\\"1.0\\\")\\n    .arg(Arg::with_name(\\\"file\\\")\\n      .short(\\\"f\\\")\\n      .long(\\\"file\\\")\\n      .help(\\\"Indicates that the input is a file path\\\")\\n      .takes_value(true))\\n      .get_matches();\\n\\n  // If --file is present, read the values from a file\\n  let reader: Box<dyn BufRead> = match matches.value_of(\\\"file\\\") {\\n    Some(file_path) => {\\n      let path = std::path::PathBuf::from(file_path);\\n      let f = File::open(path).expect(\\\"File not found\\\");\\n      Box::new(BufReader::new(f))\\n    },\\n    None => Box::new(BufReader::new(io::stdin()))\\n  };\\n\\n  // Fill mailbox\\n  let mut mailbox: [i32; 100] = [0; 100];\\n  for (i, value) in reader.lines().enumerate() {\\n    mailbox[i] = value.unwrap()\\n                      .trim()\\n                      .parse()\\n                      .expect(&format!(\\\"NaN on line {}\\\", i + 1));\\n\\n    if i == 99 {\\n      break;\\n    }\\n  }\\n\\n  println!(\\\"Instructions: {:?}\\\", &mailbox[..]);\\n}\\n\")), mdx(\"p\", null, \"We can see our current progress by printing the values stored in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mailbox\"), \" and then compile and execute our program with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo run\"), \".  Enter some numbers and then press \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CTRL + D\"), \" in Linux or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CTRL + Z\"), \" on Windows to display the values in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mailbox\"), \" array and exit the program. You can also test it with a file by executing \", mdx(\"br\", null), mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo run -- --file filename.txt\"), \".\")), mdx(\"p\", null, \"And that's it! We have our main program ready to fill the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mailbox\"), \" array with instructions for the LMC that we are going to build in the next section. \"), mdx(\"h2\", null, \"Creating the LMC as a library\"), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// lib.rs\\n\\npub fn compute(mut mailbox: [i32; 100]) {\\n  let mut program_cnt: usize = 0;\\n  let mut accumulator: i32 = 0;\\n}\\n\")), mdx(\"p\", null, \"Ideally, our LMC program could be used as a binary executable or as a library, in case we want to publish it as a crate. Create a file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/lib.rs\"), \". This file will contain all the logic for the LMC described above. In this file we will add a function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"compute\"), \" that receives the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mailbox\"), \" array. Also, we will declare two variables: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"program_cnt\"), \" representing our counter, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"accumulator\"), \", for the calculator value. Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"program_cnt\"), \" represents an index in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mailbox\"), \" array, we use the type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"usize\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// lib.rs\\n\\nuse std::convert::TryFrom;\\n\\npub fn compute(mut mailbox: [i32; 100]) {\\n  let mut program_cnt: usize = 0;\\n  let mut accumulator: i32 = 0;\\n\\n  let instruction = mailbox[program_cnt];\\n  let code : i32 = instruction / 100;\\n  let index : usize = usize::try_from(instruction % 100).unwrap();\\n}\\n\")), mdx(\"p\", null, \"An instruction in the LMC is represented by a three digits number. The first digit being the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"code\"), \", and the other digits are the index of the mailbox to apply the instruction. Notice that we cast the index from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i32\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"usize\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"try_from\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// lib.rs\\n\\nuse std::convert::TryFrom;\\n\\npub fn compute(mut mailbox: [i32; 100]) {\\n  let mut program_cnt: usize = 0;\\n  let mut accumulator: i32 = 0;\\n    \\n  let instruction = mailbox[program_cnt];\\n  let code : i32 = instruction / 100;\\n  let index : usize = usize::try_from(instruction % 100).unwrap();\\n    \\n  match code {\\n    1 => accumulator += mailbox[index], // ADD\\n    2 => accumulator -= mailbox[index], // SUBSTRACT\\n    3 => mailbox[index] = accumulator, // STORE\\n    5 => accumulator = mailbox[index], // LOAD\\n    0 => return, // HALT\\n    _ => panic!(format!(\\\"Invalid action: {}\\\", mailbox[program_cnt]))\\n  }\\n}\\n\")), mdx(\"p\", null, \"Here we implement first the simpler actions from the instruction table. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_\"), \" will be used to exit the LMC program with an error when it receives an Invalid action.\")), mdx(\"h2\", null, \"Using our library\"), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// main.rs\\n\\nuse clap::{Arg, App};\\nuse std::io::{self, BufRead, BufReader};\\nuse std::fs::File;\\n\\nfn main() {\\n  let matches = App::new(\\\"Little man computer\\\")\\n    .version(\\\"1.0\\\")\\n    .arg(Arg::with_name(\\\"file\\\")\\n      .short(\\\"f\\\")\\n      .long(\\\"file\\\")\\n      .help(\\\"Indicates that the input is a file path\\\")\\n      .takes_value(true))\\n      .get_matches();\\n\\n  // If --file is present, read the values from a file\\n  let reader: Box<dyn BufRead> = match matches.value_of(\\\"file\\\") {\\n    Some(file_path) => {\\n      let path = std::path::PathBuf::from(file_path);\\n      let f = File::open(path).expect(\\\"File not found\\\");\\n      Box::new(BufReader::new(f))\\n    },\\n    None => Box::new(BufReader::new(io::stdin()))\\n  };\\n\\n  // Fill mailbox\\n  let mut mailbox: [i32; 100] = [0; 100];\\n  for (i, value) in reader.lines().enumerate() {\\n    mailbox[i] = value.unwrap()\\n                      .trim()\\n                      .parse()\\n                      .expect(&format!(\\\"NaN on line {}\\\", i + 1));\\n\\n    if i == 99 {\\n      break;\\n    }\\n  }\\n\\n  println!(\\\"Instructions: {:?}\\\", &mailbox[..]);\\n}\\n\")), mdx(\"p\", null, \"So, let's see our progress so far. We have a program that reads a series of instructions either from the command line or from a file. There's also a library file, however, it's not being invoked by our main program.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// main.rs\\n\\nuse clap::{Arg, App};\\nuse std::io::{self, BufRead, BufReader};\\nuse std::fs::File;\\nuse lmc;\\n\\nfn main() {\\n  let matches = App::new(\\\"Little man computer\\\")\\n    .version(\\\"1.0\\\")\\n    .arg(Arg::with_name(\\\"file\\\")\\n      .short(\\\"f\\\")\\n      .long(\\\"file\\\")\\n      .help(\\\"Indicates that the input is a file path\\\")\\n      .takes_value(true))\\n      .get_matches();\\n\\n  // If --file is present, read the values from a file\\n  let reader: Box<dyn BufRead> = match matches.value_of(\\\"file\\\") {\\n    Some(file_path) => {\\n      let path = std::path::PathBuf::from(file_path);\\n      let f = File::open(path).expect(\\\"File not found\\\");\\n      Box::new(BufReader::new(f))\\n    },\\n    None => Box::new(BufReader::new(io::stdin()))\\n  };\\n\\n  // Fill mailbox\\n  let mut mailbox: [i32; 100] = [0; 100];\\n  for (i, value) in reader.lines().enumerate() {\\n    mailbox[i] = value.unwrap()\\n                      .trim()\\n                      .parse()\\n                      .expect(&format!(\\\"NaN on line {}\\\", i + 1));\\n\\n    if i == 99 {\\n      break;\\n    }\\n  }\\n\\n  println!(\\\"Instructions: {:?}\\\", &mailbox[..]);\\n}\\n\")), mdx(\"p\", null, \"Import the library.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// main.rs\\n\\nuse clap::{Arg, App};\\nuse std::io::{self, BufRead, BufReader};\\nuse std::fs::File;\\nuse lmc;\\n\\nfn main() {\\n  let matches = App::new(\\\"Little man computer\\\")\\n    .version(\\\"1.0\\\")\\n    .arg(Arg::with_name(\\\"file\\\")\\n      .short(\\\"f\\\")\\n      .long(\\\"file\\\")\\n      .help(\\\"Indicates that the input is a file path\\\")\\n      .takes_value(true))\\n      .get_matches();\\n\\n  // If --file is present, read the values from a file\\n  let reader: Box<dyn BufRead> = match matches.value_of(\\\"file\\\") {\\n    Some(file_path) => {\\n      let path = std::path::PathBuf::from(file_path);\\n      let f = File::open(path).expect(\\\"File not found\\\");\\n      Box::new(BufReader::new(f))\\n    },\\n    None => Box::new(BufReader::new(io::stdin()))\\n  };\\n\\n  // Fill mailbox\\n  let mut mailbox: [i32; 100] = [0; 100];\\n  for (i, value) in reader.lines().enumerate() {\\n    mailbox[i] = value.unwrap()\\n                      .trim()\\n                      .parse()\\n                      .expect(&format!(\\\"NaN on line {}\\\", i + 1));\\n\\n    if i == 99 {\\n      break;\\n    }\\n  }\\n\\n  // Execute program\\n  lmc::compute(mailbox);\\n}\\n\")), mdx(\"p\", null, \"And then call the function compute by passing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mailbox\"), \" array as a parameter.\")), mdx(\"p\", null, \"Execute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo run\"), \" and enter the following instructions:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"901\\n902\\n000\\n(remember to use `CTRL + D` in Linux / `CTRL + Z` in Windows)\\n\")), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// lib.rs\\n\\nuse std::convert::TryFrom;\\nuse text_io::read;\\nuse std::io;\\nuse std::io::Write;\\n\\npub fn compute(mut mailbox: [i32; 100]) {\\n  let mut program_cnt: usize = 0;\\n  let mut accumulator: i32 = 0;\\n    \\n  let instruction = mailbox[program_cnt];\\n  let code : i32 = instruction / 100;\\n  let index : usize = usize::try_from(instruction % 100).unwrap();\\n    \\n  match code {\\n    1 => accumulator += mailbox[index], // ADD\\n    2 => accumulator -= mailbox[index], // SUBSTRACT\\n    3 => mailbox[index] = accumulator, // STORE\\n    5 => accumulator = mailbox[index], // LOAD\\n    0 => return, // HALT\\n    _ => panic!(format!(\\\"Invalid action: {}\\\", mailbox[program_cnt]))\\n  }\\n}\\n\\n\")), mdx(\"p\", null, \"You'll notice that after entering the instructions, only the first instruction is executed. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// lib.rs\\n\\nuse std::convert::TryFrom;\\nuse text_io::read;\\nuse std::io;\\nuse std::io::Write;\\n\\npub fn compute(mut mailbox: [i32; 100]) {\\n  let mut program_cnt: usize = 0;\\n  let mut accumulator: i32 = 0;\\n    \\n  loop {\\n    let instruction = mailbox[program_cnt];\\n    let code : i32 = instruction / 100;\\n    let index : usize = usize::try_from(instruction % 100).unwrap();\\n    \\n    match code {\\n      1 => accumulator += mailbox[index], // ADD\\n      2 => accumulator -= mailbox[index], // SUBSTRACT\\n      3 => mailbox[index] = accumulator, // STORE\\n      5 => accumulator = mailbox[index], // LOAD\\n      0 => return, // HALT\\n      _ => panic!(format!(\\\"Invalid action: {}\\\", mailbox[program_cnt]))\\n    }\\n        \\n    program_cnt += 1;\\n  }\\n}\\n\")), mdx(\"p\", null, \"We are missing a loop in our library. Add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"loop\"), \" and increase the counter on each iteration: \")), mdx(\"p\", null, \"Now if we run the program with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo run\"), \", we'll see it executes each instruction.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\\n     Running `target/debug/lmc`\\n901\\n902\\n000\\nInput: \\n\")), mdx(\"h2\", null, \"Input, output and branching instructions\"), mdx(\"p\", null, \"To implement the READ instruction, we'll use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"text_io\"), \" crate. Add it to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cargo.toml\"), \" file\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-toml\"\n  }), \"[dependencies]\\nclap = \\\"2.33.0\\\"\\ntext_io = \\\"0.1.8\\\"\\n\")), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// lib.rs\\n\\nuse std::convert::TryFrom;\\nuse text_io::read;\\nuse std::io;\\nuse std::io::Write;\\n\\npub fn compute(mut mailbox: [i32; 100]) {\\n  let mut program_cnt: usize = 0;\\n  let mut accumulator: i32 = 0;\\n    \\n  loop {\\n    let instruction = mailbox[program_cnt];\\n    let code : i32 = instruction / 100;\\n    let index : usize = usize::try_from(instruction % 100).unwrap();\\n\\n    match code {\\n      1 => accumulator += mailbox[index], // ADD\\n      2 => accumulator -= mailbox[index], // SUBSTRACT\\n      3 => mailbox[index] = accumulator, // STORE\\n      5 => accumulator = mailbox[index], // LOAD\\n      0 => return, // HALT\\n      _ => panic!(format!(\\\"Invalid action: {}\\\", mailbox[program_cnt]))\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Let's go back and edit \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lib.rs\"), \". We are only missing a few instructions to complete our LMC.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// lib.rs\\n\\nuse std::convert::TryFrom;\\nuse text_io::read;\\nuse std::io;\\nuse std::io::Write;\\n\\npub fn compute(mut mailbox: [i32; 100]) {\\n  let mut program_cnt: usize = 0;\\n  let mut accumulator: i32 = 0;\\n    \\n  loop {\\n    let instruction = mailbox[program_cnt];\\n    let code : i32 = instruction / 100;\\n    let index : usize = usize::try_from(instruction % 100).unwrap();\\n\\n    match code {\\n      1 => accumulator += mailbox[index], // ADD\\n      2 => accumulator -= mailbox[index], // SUBSTRACT\\n      3 => mailbox[index] = accumulator, // STORE\\n      5 => accumulator = mailbox[index], // LOAD\\n      9 => match index {\\n        1 => { // INPUT\\n          print!(\\\"Input: \\\");\\n          io::stdout().flush().unwrap();\\n          let value: String = read!(\\\"{}\\\\n\\\");\\n          accumulator = value.parse().expect(\\\"Invalid input value\\\");\\n        },\\n        _ => panic!(format!(\\\"Invalid action: {}\\\", mailbox[program_cnt]))\\n      },\\n      0 => return, // HALT\\n      _ => panic!(format!(\\\"Invalid action: {}\\\", mailbox[program_cnt]))\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"We can implement instruction \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"901\"), \", using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"read!\"), \" macro. Notice that we used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"io::stdout().flush().unwrap()\"), \" after the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"print!\"), \". This is because we want to display the string \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"Input: \\\"\"), \" before we read a value. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// lib.rs\\n\\nuse std::convert::TryFrom;\\nuse text_io::read;\\nuse std::io;\\nuse std::io::Write;\\n\\npub fn compute(mut mailbox: [i32; 100]) {\\n  let mut program_cnt: usize = 0;\\n  let mut accumulator: i32 = 0;\\n    \\n  loop {\\n    let instruction = mailbox[program_cnt];\\n    let code : i32 = instruction / 100;\\n    let index : usize = usize::try_from(instruction % 100).unwrap();\\n\\n    match code {\\n      1 => accumulator += mailbox[index], // ADD\\n      2 => accumulator -= mailbox[index], // SUBSTRACT\\n      3 => mailbox[index] = accumulator, // STORE\\n      5 => accumulator = mailbox[index], // LOAD\\n      9 => match index {\\n        1 => { // INPUT\\n          print!(\\\"Input: \\\");\\n          io::stdout().flush().unwrap();\\n          let value: String = read!(\\\"{}\\\\n\\\");\\n          accumulator = value.parse().expect(\\\"Invalid input value\\\");\\n        },\\n        2 => println!(\\\"Output: {}\\\", accumulator), // OUTPUT\\n        _ => panic!(format!(\\\"Invalid action: {}\\\", mailbox[program_cnt]))\\n      },\\n      0 => return, // HALT\\n      _ => panic!(format!(\\\"Invalid action: {}\\\", mailbox[program_cnt]))\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"To implement the PRINT instruction (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"902\"), \") we only need to display the value we have in the accumulator with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"println!\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"// lib.rs\\n\\nuse std::convert::TryFrom;\\nuse text_io::read;\\nuse std::io;\\nuse std::io::Write;\\n\\npub fn compute(mut mailbox: [i32; 100]) {\\n  let mut program_cnt: usize = 0;\\n  let mut accumulator: i32 = 0;\\n    \\n  loop {\\n    let instruction = mailbox[program_cnt];\\n    let code : i32 = instruction / 100;\\n    let index : usize = usize::try_from(instruction % 100).unwrap();\\n\\n    match code {\\n      1 => accumulator += mailbox[index], // ADD\\n      2 => accumulator -= mailbox[index], // SUBSTRACT\\n      3 => mailbox[index] = accumulator, // STORE\\n      5 => accumulator = mailbox[index], // LOAD\\n      6 => { // BRANCH\\n        program_cnt = index;\\n        continue;\\n      },\\n      7 => { // BRANCH IF ZERO\\n        if accumulator == 0 {\\n          program_cnt = index;\\n          continue;\\n        }\\n      },\\n      8 => { // BRANCH IF POSITIVE\\n        if accumulator >= 0 {\\n          program_cnt = index;\\n          continue;\\n        }\\n      },\\n      9 => match index {\\n        1 => { // INPUT\\n          print!(\\\"Input: \\\");\\n          io::stdout().flush().unwrap();\\n          let value: String = read!(\\\"{}\\\\n\\\");\\n          accumulator = value.parse().expect(\\\"Invalid input value\\\");\\n        },\\n        2 => println!(\\\"Output: {}\\\", accumulator), // OUTPUT\\n        _ => panic!(format!(\\\"Invalid action: {}\\\", mailbox[program_cnt]))\\n      },\\n      0 => return, // HALT\\n      _ => panic!(format!(\\\"Invalid action: {}\\\", mailbox[program_cnt]))\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The instructions \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6xx\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"7xx\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"8xx\"), \" are very similar except for their conditions to change the counter value. We need to use a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"continue\"), \" to avoid increasing the program counter after executing the instruction.\")), mdx(\"p\", null, \"And with this, the LMC is complete! You can create a more complex program to see the LMC in action:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"countdown.txt\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"901\\n902\\n308\\n207\\n308\\n801\\n000\\n001\\n000\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"cargo run -- --file ./countdown.txt\\n\")), mdx(\"h2\", null, \"Final thoughts\"), mdx(\"p\", null, \"The LMC program is like assembly language that a CPU understands, and it serves as a good introduction to learn how a computer works. Try creating some programs and find ways to improve the LMC! (some ideas: extend the program with non-standard instructions to print ascii characters, create a lexer to accept the mnemonics instead of the numeric codes, validate the instructions and input data).\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/lmc/","title":"Little Man Computer","tags":[],"keywords":[],"date":"April 10, 2020"},"previous":{"__typename":"MdxBlogPost","id":"f34f9e7a-9002-5fc0-94aa-a532e598d465","excerpt":"Nothing to see here yet. Just testing Gatsby.","slug":"/hello-world/","title":"Hello world!","date":"April 09, 2020"},"next":{"__typename":"MdxBlogPost","id":"e174de5b-e4e8-52d9-a8a6-25211bf48c68","excerpt":"One of the inconveniences of being a remote worker in the Dominican Republic is that there's always a chance of power outage. So far I have…","slug":"/remote-dev-machine/","title":"Setting up a remote development environment","date":"April 18, 2020"}},"pageContext":{"id":"bbc52208-7123-5822-b72b-143ef679c1f5","previousId":"f34f9e7a-9002-5fc0-94aa-a532e598d465","nextId":"e174de5b-e4e8-52d9-a8a6-25211bf48c68"}}}