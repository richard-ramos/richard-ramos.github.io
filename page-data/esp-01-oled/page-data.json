{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/esp-01-oled/","result":{"data":{"site":{"siteMetadata":{"title":"Hello, I'm RichΛrd","social":[{"name":"twitter","url":"https://twitter.com/richardramos_me"},{"name":"github","url":"https://github.com/richard-ramos"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"353f79f0-92c1-5cb4-8ee2-4259c8290052","excerpt":"In this post we are going to add a screen to the  ESP-01  to display data obtained from a webservice. The  ESP-01  is limited in the number…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Adding a OLED screen to the ESP-01\",\n  \"date\": \"2020-04-26T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"img\", {\n    src: eth\n  }), mdx(\"p\", null, \"In this post we are going to add a screen to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ESP-01\"), \" to display data obtained from a webservice. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ESP-01\"), \" is limited in the number of GPIO pins available, with up to 4 pins availables if we count the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TX\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RX\"), \" pins (but once you use those, you will no longer be able to use the serial monitor, as those pins will become \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GPIO\"), \" and not transmit serial data). This might be a stopper for many projects, but not for this particular scenario, if we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I2C\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I2C\"), \" is a protocol that lets multiple secondary chips communicate with a primary chip. It only requires two connections to exchange information. For this scenario I will use an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"I2C\"), \" OLED screen that will be connected to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GPIO0\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GPIO2\"), \" pins on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ESP-01\"), \".\"), mdx(\"h2\", null, \"Tools\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Multimeter (required to test continuity and verify voltage)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Wire strippers or an exacto knife\")), mdx(\"h2\", null, \"Materials\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ESP-01\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Some way to program the ESP-01, either following the previous tutorial, or using an UART programmer\\nBreadboard\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ESP-01 breadboard adapter (Can be DIY)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1 tactile switch\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"2 10K\", \"\\u2126\", \" resistors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"20 gauge single wire cables or jumper cables\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A 3.3v power source, or a 5V power source and a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"LM1117T\"), \" voltage regulator to drop voltage to 3.3\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1 100\", \"\\u03BC\", \"F electrolytic capacitor\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1 0.1\", \"\\u03BC\", \"F ceramic capacitor\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1 128x64 I2C OLED screen\")), mdx(\"h2\", null, \"The schematic\"), mdx(\"img\", {\n    src: sch\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The tactile button is used as a reset switch connecting the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RST\"), \" pin to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"GND\"), \" when pressed, and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RST\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"VCC\"), \" through a 10K pull up resistor. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"GPIO0\"), \" is connected to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SCL\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"GPIO2\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SDA\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"CH_PD\"), \" is pulled to 3.3V via a 10K resistor\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I added some decoupling capacitors. The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ESP-01\"), \" uses a lot of current, so I added the 100\", \"\\u03BC\", \"F capacitor to act as a power reserve and keep the voltage stable and the 0.1\", \"\\u03BC\", \"F to filter noise. These capacitors have to be close to the ESP\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Also, a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"LM1117T\"), \" voltage regulator is used to drop the voltage from 5V to 3.3V\")), mdx(\"p\", null, \"This schematic will look similar to this picture once reproduced in a breadboard\"), mdx(\"img\", {\n    src: bb\n  }), mdx(\"h2\", null, \"Programming\"), mdx(\"p\", null, \"Install the following libraries, via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tools > Manage Libraries\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Adafruit GFX Library by Adafruit version 1.7.5\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Adafruit SSD1306 by Adafruit version 2.2.0\"), \" \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ArduinoJson by Benoit Blanchon version 6.15.2\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"esp8266 by ESP8266 Community version 2.6.3\"), \" (you should have this installed from the previous tutorial)\")), mdx(\"p\", null, \"With these libraries we should pretty much be able to communicate with any webservice, parse its response and display it on the OLED screen. Here is some example code that uses these libraries to connect and obtain the price for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ETH\"), \" from \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.cryptocompare.com\"\n  }), \"cryptocompare.com\"), \". \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"#include <Wire.h>\\n#include <Adafruit_GFX.h>\\n#include <Adafruit_SSD1306.h>\\n#include <ESP8266WiFi.h>\\n#include <WiFiClientSecure.h>\\n#include <time.h>\\n#include <ESP8266HTTPClient.h>\\n#include <ArduinoJson.h>\\n\\n#define SCREEN_WIDTH 128 // OLED display width, in pixels\\n#define SCREEN_HEIGHT 64 // OLED display height, in pixels\\n\\n// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)\\n#define OLED_RESET -1 // Reset pin # (or -1 if sharing Arduino reset pin)\\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);\\n\\nconst char *ssid = \\\"YOUR_WIFI_SSID\\\";\\nconst char *pass = \\\"YOUR_PASSWORD\\\";\\n\\n// SSL certificate of cryptocompare.com\\nconst char digicert[] PROGMEM = R\\\"EOF(\\n-----BEGIN CERTIFICATE-----\\nMIIEADCCAuigAwIBAgIBADANBgkqhkiG9w0BAQUFADBjMQswCQYDVQQGEwJVUzEh\\nMB8GA1UEChMYVGhlIEdvIERhZGR5IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBE\\nYWRkeSBDbGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA0MDYyOTE3\\nMDYyMFoXDTM0MDYyOTE3MDYyMFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRo\\nZSBHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR28gRGFkZHkgQ2xhc3Mg\\nMiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAwDQYJKoZIhvcNAQEBBQADggEN\\nADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWizV3GgXne77ZtJ6XCA\\nPVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HFiH7Eux6w\\nwdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLOtXi\\nEqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWoriMY\\navx4A6lNf4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZEewo+\\nYihfukEHU1jPEX44dMX4/7VpkI+EdOqXG68CAQOjgcAwgb0wHQYDVR0OBBYEFNLE\\nsNKR1EwRcbNhyz2h/t2oatTjMIGNBgNVHSMEgYUwgYKAFNLEsNKR1EwRcbNhyz2h\\n/t2oatTjoWekZTBjMQswCQYDVQQGEwJVUzEhMB8GA1UEChMYVGhlIEdvIERhZGR5\\nIEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBEYWRkeSBDbGFzcyAyIENlcnRpZmlj\\nYXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQAD\\nggEBADJL87LKPpH8EsahB4yOd6AzBhRckB4Y9wimPQoZ+YeAEW5p5JYXMP80kWNy\\nOO7MHAGjHZQopDH2esRU1/blMVgDoszOYtuURXO1v0XJJLXVggKtI3lpjbi2Tc7P\\nTMozI+gciKqdi0FuFskg5YmezTvacPd+mSYgFFQlq25zheabIZ0KbIIOqPjCDPoQ\\nHmyW74cNxA9hi63ugyuV+I6ShHI56yDqg+2DzZduCLzrTia2cyvk0/ZM/iZx4mER\\ndEr/VxqHD3VILs9RaRegAhJhldXRQLIQTO7ErBBDpqWeCtWVYpoNz4iCxTIM5Cuf\\nReYNnyicsbkqWletNw+vHX/bvZ8=\\n-----END CERTIFICATE-----\\n)EOF\\\";\\n\\nHTTPClient https;\\n\\n#define LOGO_WIDTH 23\\n#define LOGO_HEIGHT 38\\n\\nconst char * apiURL = \\\"https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD\\\";\\n\\n// ETH logo\\nconst unsigned char eth [] PROGMEM = {\\n  0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, 0x78, 0x00, 0x00, 0x78, 0x00, 0x00, \\n  0xfc, 0x00, 0x01, 0xfe, 0x00, 0x01, 0xfe, 0x00, 0x03, 0xff, 0x00, 0x03, 0xff, 0x00, 0x07, 0xff, \\n  0x80, 0x0f, 0xff, 0xc0, 0x0f, 0xff, 0xc0, 0x1f, 0xff, 0xe0, 0x1f, 0xff, 0xe0, 0x3f, 0xff, 0xf0, \\n  0x3f, 0xff, 0xf0, 0x7f, 0xff, 0xf8, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xf8, 0x1f, 0xff, 0xe0, 0x07, \\n  0xff, 0x80, 0x43, 0xff, 0x08, 0x60, 0xfc, 0x18, 0x38, 0x78, 0x70, 0x1c, 0x00, 0xe0, 0x1f, 0x03, \\n  0xe0, 0x0f, 0xcf, 0xc0, 0x07, 0xff, 0x80, 0x03, 0xff, 0x00, 0x03, 0xff, 0x00, 0x01, 0xfe, 0x00, \\n  0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x78, 0x00, 0x00, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, \\n  0x00, 0x00\\n};\\n\\n\\n// Set time via NTP, as required for x.509 validation\\nvoid setClock() {\\n  configTime(3 * 3600, 0, \\\"pool.ntp.org\\\", \\\"time.nist.gov\\\");\\n\\n  resetDisplay();\\n  println(\\\"NTP time sync: \\\");\\n  \\n  time_t now = time(nullptr);\\n  while (now < 8 * 3600 * 2) {\\n    delay(500);\\n    print(\\\".\\\");\\n    now = time(nullptr);\\n  }\\n  \\n  Serial.println(\\\"\\\");\\n  struct tm timeinfo;\\n  gmtime_r(&now, &timeinfo);\\n  \\n  resetDisplay();\\n  println(\\\"Current time: \\\");\\n  println(asctime(&timeinfo));\\n  \\n  delay(2000);\\n}\\n\\nvoid resetDisplay(){\\n  display.clearDisplay();\\n  display.setCursor(0, 0);\\n}\\n\\nvoid println(const char * str){\\n  Serial.println(str);\\n  display.println(str);\\n  display.display();\\n}\\n\\nvoid print(char * str){\\n  Serial.print(str);\\n  display.write(str);\\n  display.display();\\n}\\n\\nvoid drawCentreString(const char *buf, int x, int y)\\n{\\n    int16_t x1, y1;\\n    uint16_t w, h;\\n    display.getTextBounds(buf, x, y, &x1, &y1, &w, &h); //calc width of new string\\n    display.setCursor(x - w / 2, y);\\n    display.print(buf);\\n    Serial.print(buf);\\n    display.display();\\n}\\n\\nvoid printBTCLogo() {\\n  display.drawBitmap(\\n    (display.width()  - LOGO_WIDTH ) / 2,\\n    (display.height() - LOGO_HEIGHT) / 2,\\n    eth, LOGO_WIDTH, LOGO_HEIGHT, 1);\\n}\\n\\nvoid fetchURL(BearSSL::WiFiClientSecure *client) {\\n  resetDisplay();\\n  \\n  if (https.begin(*client, apiURL)) {\\n    println(\\\"Obtaining price...\\\");\\n    \\n    \\n    // start connection and send HTTP header\\n    int httpCode = https.GET();\\n  \\n    // httpCode will be negative on error\\n    if (httpCode > 0) {\\n      // HTTP header has been send and Server response header has been handled\\n      Serial.printf(\\\"[HTTPS] GET... code: %d\\\\n\\\", httpCode);\\n  \\n      // file found at server\\n      if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {\\n        String payload = https.getString();\\n        Serial.println(payload);\\n  \\n        StaticJsonDocument<200> doc;\\n        deserializeJson(doc, payload);\\n        String price = doc[\\\"USD\\\"];\\n\\n        resetDisplay();\\n        printBTCLogo();\\n        drawCentreString(price.c_str(), 64, 55);\\n        display.display();\\n        \\n      }\\n    } else {\\n      Serial.printf(\\\"[HTTPS] GET... failed, error: %s\\\\n\\\", https.errorToString(httpCode).c_str());\\n      display.println(sprintf(\\\"[HTTPS] GET... failed, error: %s\\\\n\\\", https.errorToString(httpCode).c_str()));\\n      display.display();\\n    }\\n    https.end();\\n  } else {\\n    println(\\\"[HTTPS] Unable to connect\\\");\\n  }\\n}\\n\\n\\nvoid connect() {\\n  BearSSL::WiFiClientSecure client;\\n  BearSSL::X509List cert(digicert);\\n  client.setTrustAnchors(&cert);\\n  setClock();\\n  fetchURL(&client);\\n}\\n\\n\\nvoid setup() {\\n  Serial.begin(115200);\\n  Wire.pins(0, 2);\\n  \\n   // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally\\n  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\\n    Serial.println(\\\"SSD1306 allocation failed\\\");\\n    for(;;); // Don't proceed, loop forever\\n  }\\n\\n  resetDisplay();\\n  display.display();\\n  delay(100);\\n\\n  display.setTextSize(1);      // Normal 1:1 pixel scale\\n  display.setTextColor(SSD1306_WHITE); // Draw white text\\n  display.cp437(true);         // Use full 256 char 'Code Page 437' font\\n\\n  // We start by connecting to a WiFi network\\n  println(\\\"Connecting to\\\");\\n  println(ssid);\\n  \\n  WiFi.mode(WIFI_STA);\\n  WiFi.begin(ssid, pass);\\n\\n  while (WiFi.status() != WL_CONNECTED) {\\n    delay(500);\\n    Serial.print(\\\".\\\");\\n    display.write(\\\".\\\");\\n    display.display();\\n  }\\n  \\n  resetDisplay();\\n  println(\\\"WiFi connected\\\");\\n  println(WiFi.localIP().toString().c_str());\\n  \\n  delay(1000);\\n}\\n\\n\\nvoid loop() {\\n    connect();\\n    delay(60000);\\n}\\n\")), mdx(\"p\", null, \"Some things worth noticing are that the ETH logo was generated using this \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://javl.github.io/image2cpp/\"\n  }), \"website\"), \". There's an NTP step used to obtain the current time, this is necessary for validating the SSL certificate. Also, depending on you screen, you might have to change the I2C address from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x3C\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x3D\"), \". \"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/esp-01-oled/","title":"Adding a OLED screen to the ESP-01","tags":[],"keywords":[],"date":"April 26, 2020"},"previous":{"__typename":"MdxBlogPost","id":"aff624db-3b5c-558f-8e3c-705273e2893a","excerpt":"The  ESP8266  is an awesome Wi-Fi microcontroller, with full TCP/IP capability. It's very popular among hackers and hundreds of tutorials…","slug":"/esp-01/","title":"Wiring up a Wifi Module ESP-01","date":"April 26, 2020"},"next":null},"pageContext":{"id":"353f79f0-92c1-5cb4-8ee2-4259c8290052","previousId":"aff624db-3b5c-558f-8e3c-705273e2893a"}}}